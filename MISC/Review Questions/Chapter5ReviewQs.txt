1-A hash code value is of type integer.

2-First, the hash function is used to determine the index of an item by hashing the value of that item. Then to determine the index of an item in a list within the length range of the list, the list's size is determined and the reminder of dividing the hash value with the length of the list serves as the index of an item. To sum it up, the hashed value of the item is modular operated on with the length of the list to determine the index for that item within the list. 

3-A placeholder or a none value reference in a list are cruicial to detemining whether a given item is in the list or not by using the calculated index value of the given item value to locate. If the placeholder or the none value reference are found, then we know there wasn't an item added to the list yet, however, if the index is not none and we did not find the value we were looking for, then the item would have been moved to the next available position due to collision from the same hashed index value. In this cases, we have to look at the chain of values where items would be located based on the value of the hash function and the next slots in the hashset/dictinary.

4-As there will always be a finite number of integers, and the possibility of two different items to have the same index value, based on the modular calculation, the collision resolution would help us to find the next best available index to place the overlapping iteem in the list.

5-A set is a collection of unique values hashed before stored in a list to make accessibility of the values go faster and more efficient. A map applies the very same description of the list but adds another object to make a key-value relationship. This relationship is uses hashing for the key, which is a unique value like in sets, and corresponds this hashed value with an item, value, which does not require any hashing.

6-A dictionary contains key-value pairs with unique keys. A set does not allow repetition of values, which is exactly how keys function in dictionaries, and with that in mind we can use the keys from dictionaries as objects for sets. We can test the membership of the key-value pairs from a dictionary by checking whether a given key is in a set or not. However, since dictionaries are immutable, we cannot directly add a dictinary object to the set, but we know how to locate an item from a dictinary through keys. And with that in mind, adding a list of keys from a given dictionary to our set can be done using the set's add method. The test of a membership of a given item can then be done by this item's key just like any item's membership verification using the set's in method.

7-The load factors helps determine how full the hashset's list by taking the size of the list and the number of items stored in it into consideration. The concept of load factor shows us how intensive it is to search for an item in a hash set. With higher load factor, a higher chance of a collision in a hash table is found, which makes finding an item from a list more computationally intensive. However, having a small load factor would mean that there are more empty positions in the list than needed, making the membership of a item from a list faster.

8-Rehashing is the process of creating a new list due to the load factor of the original list being great than 75% as the new values are being added to the original list. And then hashing the new values again to accommodate the size of the new list.

9-Memoization is used when a function is called multiple times with the same arguements. As we call a function which has been previously used to determine some result, we could simply use the result from previous calls to compute the desired result from the current call. Since recursive functions call themselves at some point during the implementation, memoization can be useful in handling functions very well in terms of time efficiency.

10-True. Lets say we know the memoized values for n-1 and n-2 factorials, in order to determine the n factorial, we will need to know the n-1 and n-2 factorials as well, and since we already memozed those factorials, we do not hae to calculate them again during the process of calculating the n factorial. Memoization like this will make finding the n factorial faster compared to calculating it from scratch. 